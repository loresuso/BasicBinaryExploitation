# FORMAT challenge HTB write-up

Format is pwn challenge from HTB. As the name suggests, it deals with format string vulnerabilities. 

Let's start analyzing the binary. First, running <code>checksec</code> on the binary gives this output: 

```shell
$ checksec format 
[*] '/home/ubuntu/lettieri/BasicBinaryExploitation/other-challenges/format-challenge-htb/format'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
```

All the mitigation techniques are enabled. Secondly, let's take a look at the binary using <code>objdump -d ./format</code>. The format string vulnerability is in the <code>echo</code> function: 

```assembly
00000000000011a9 <echo>:
    11a9:	f3 0f 1e fa          	endbr64 
    11ad:	55                   	push   %rbp
    11ae:	48 89 e5             	mov    %rsp,%rbp
    11b1:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp
    11b8:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    11bf:	00 00 
    11c1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    11c5:	31 c0                	xor    %eax,%eax
    11c7:	48 8b 15 62 2e 00 00 	mov    0x2e62(%rip),%rdx        # 4030 <stdin@@GLIBC_2.2.5>
    11ce:	48 8d 85 f0 fe ff ff 	lea    -0x110(%rbp),%rax
    11d5:	be 00 01 00 00       	mov    $0x100,%esi
    11da:	48 89 c7             	mov    %rax,%rdi
    11dd:	e8 be fe ff ff       	callq  10a0 <fgets@plt>
    11e2:	48 8d 85 f0 fe ff ff 	lea    -0x110(%rbp),%rax
    11e9:	48 89 c7             	mov    %rax,%rdi
    11ec:	b8 00 00 00 00       	mov    $0x0,%eax
    11f1:	e8 9a fe ff ff       	callq  1090 <printf@plt>
    11f6:	eb cf                	jmp    11c7 <echo+0x1e>

```

In fact, the <code>printf</code> function is called with only one parameter and that parameter is controlled by the attacker. We can also see a weird thing: this function never returns, because it doesn't have an epilogue and the last instruction is a <code>jmp</code>. This of course was intended: we cannot just overwrite the return address to redirect code execution, otherwise it would be so much easier. Furthermore, given that this binary has Full RELRO, we cannot overwrite the Global Offset Table. 

So, what can we do? Are there any particular pointers that we can overwrite? 

After some googling, this <https://www.jaybosamiya.com/blog/2017/04/06/adv-format-string/)> came out. In particular it says: 
> If we have a read only .GOT section, then the "standard" attack of overwriting the GOT will not work. In this case, we look for alternative areas that can be overwritten (preferably function pointers). Some such areas are: __malloc_hook (see man page for the same), stdin's vtable pointer to write or flush, etc. In such a scenario, having access to the libc sources is extremely useful. As for overwriting the __malloc_hook, it works even if the application doesn't call malloc, since it is calling printf (or similar), and internally, if we pass a width specifier greater than 64k (say %70000c), then it will call malloc, and thus whatever address was specified at the global variable __malloc_hook.

<code>__malloc_hook</code> is a pointer to a function that is called everytime the <code>malloc</code> is called, just before it. It is used mainly for debugging but this time we can exploit it to redirect code execution. 
So what we have to do is to overwrite the variable <code>__malloc_hook</code> inside libc and then trigger <code>printf</code> to call <code>malloc</code> by making it allocate a big internal buffer.

Some problem may arises:

1. The downloadable folder doesn't contain any libc. So, in order to build a successful attack, we have to retrieve the version of libc that is used on the remote server. This can be done by using the arbitrary read primitive built with a format string attack, by reading the addresses contained in the Global Offset Table and then using a libc database like this <https://libc.rip/>
2. Before the step before, we should be able to retrieve the binary base address, since PIE is enabled. Once it is known, we can easily find the offsets of the GOT entries. We may leak more than one libc function addresses in order to have only one candidate libc. 

Once that those steps are performed, we can simply write at the <code>__malloc_hook</code> address the address of one_gadget. This of course can be obtained by running one_gadget over the leaked libc. Then we trigger printf to call malloc and we get the flag!!!

Please, take a look at solve.py
