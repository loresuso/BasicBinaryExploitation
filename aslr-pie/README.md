## Lessons learned :heavy_check_mark:

- <code>server_0</code>: this server was compiled to have ASLR enables but not PIE. We can user buffer overflow to inject a ROP chain in order to call the write function a second time, 
giving it the address of the got. This reveals the entry of the got corresponding to setsockopt. By computing the offset of the function inside libc (using nm -D), the libc base
address can be obtained. Once we know that address, we can let ropper generate a chain for executing a shell.

- <code>server_1</code>: this server was compiled to have ASLR enables but not PIE, and also have a buffer overlflow vulnerability. This time, we cannot just call write to leak the
content of the got, because that function is not used. The hint of the usefulGadget shows that we have to use an add instruction. We can compute the offset between read and write
functions in libc, then add it to the got entry of the read. In this way, the next time that read@plt is called, the function will instead call write(). So, like in the previous exercise, 
we can leak the address of setsockopt, obtain the libc base address and then generate the rop chain for executing the shell.

- <code>server_2</code>: on-going
