## Lessons learned :heavy_check_mark:

- <code>server_0</code>: this server was compiled to have ASLR enables but not PIE. We can user buffer overflow to inject a ROP chain in order to call the write function a second time, 
giving it the address of the got. This reveals the entry of the got corresponding to setsockopt. By computing the offset of the function inside libc (using nm -D), the libc base
address can be obtained. Once we know that address, we can let ropper generate a chain for executing a shell.

- <code>server_1</code>: this server was compiled to have ASLR enables but not PIE, and also have a buffer overlflow vulnerability. This time, we cannot just call write to leak the
content of the got, because that function is not used. The hint of the usefulGadget shows that we have to use an add instruction. We can compute the offset between read and write
functions in libc, then add it to the got entry of the read. In this way, the next time that read@plt is called, the function will instead call write(). So, like in the previous exercise, 
we can leak the address of setsockopt, obtain the libc base address and then generate the rop chain for executing the shell.

- <code>server_2</code>: this server is compiled in order to have also PIE. However, return addresses are on the stack and can be used to leak the binary base address. Here we can make two functions' stack frame be partially overlapped when called by anothe function, and trick one function to send us the content of the previous stack frame, including the previous return address. By knowing that, you get to know the binary base address, then libc and then ROP will let you have a shell. <Rear Window!>
